
.. DO NOT EDIT.
.. THIS FILE WAS AUTOMATICALLY GENERATED BY SPHINX-GALLERY.
.. TO MAKE CHANGES, EDIT THE SOURCE PYTHON FILE:
.. "auto_examples/problems/ex_03_different_policies.py"
.. LINE NUMBERS ARE GIVEN BELOW.

.. only:: html

.. rst-class:: sphx-glr-example-title

.. _sphx_glr_auto_examples_problems_ex_03_different_policies.py:

Using different policies
------------------------

.. GENERATED FROM PYTHON SOURCE LINES 8-18

This example shows how to use different policies.

A policy is the rule which sets of transport maps are computed given different distributions of cells.

Some problem classes require a certain policy, e.g. the :class:`moscot.problems.space.MappingProblem` 
only works with the :class:`moscot.problems._subset_policy.ExternalStarPolicy` meaning that all spatial 
batches from the :class:`anndata.AnnData` object are mapped to the same single cell reference cell distribution. 

Each problem class has a set of valid policies. For the :class:`moscot.problems.time.LineageProblem` and the 
:class:`moscot.problems.time.TemporalProblem` we can choose among different policies which we demonstrate below.

.. GENERATED FROM PYTHON SOURCE LINES 18-24

.. code-block:: default


    from moscot.problems.time import TemporalProblem
    from moscot.datasets import simulation

    adata = simulation(size=15360)








.. GENERATED FROM PYTHON SOURCE LINES 25-28

This simulated dataset contains single cell data across 4 time point, i.e. day 11.0, 12.0, 13.0 and 14.0.

The policy allows us to determine which transport maps we want to compute.

.. GENERATED FROM PYTHON SOURCE LINES 30-32

Different policies
******************

.. GENERATED FROM PYTHON SOURCE LINES 32-36

.. code-block:: default


    # In the following, we consider a few policies which can be used for the 
    # :class:`moscot.problems.time.TemporalProblem`. 








.. GENERATED FROM PYTHON SOURCE LINES 37-39

Sequential policy
~~~~~~~~~~~~~~~~~

.. GENERATED FROM PYTHON SOURCE LINES 41-43

We start with the default policy, which is the sequential policy.
The following code shows which OT problems are prepared to be solved.

.. GENERATED FROM PYTHON SOURCE LINES 43-48

.. code-block:: default


    tp_sequential = TemporalProblem(adata)
    tp_sequential = tp_sequential.prepare(time_key="day", policy="sequential")
    tp_sequential.problems





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    INFO:root:Computing pca with `n_comps = {n_comps}` and `joint_space = {joint_space}`.
    INFO:root:Computing pca with `n_comps = {n_comps}` and `joint_space = {joint_space}`.
    INFO:root:Computing pca with `n_comps = {n_comps}` and `joint_space = {joint_space}`.

    {(11.0, 12.0): BirthDeathProblem[shape=(2048, 4096)], (10.0, 11.0): BirthDeathProblem[shape=(1024, 2048)], (12.0, 13.0): BirthDeathProblem[shape=(4096, 8192)]}



.. GENERATED FROM PYTHON SOURCE LINES 49-50

We see that all consecutive pairs of values in the `time_key` column are used to create an OT problem

.. GENERATED FROM PYTHON SOURCE LINES 52-54

Upper triangular policy
~~~~~~~~~~~~~~~~~~~~~~~

.. GENERATED FROM PYTHON SOURCE LINES 54-59

.. code-block:: default


    tp_triu = TemporalProblem(adata)
    tp_triu = tp_triu.prepare(time_key="day", policy="triu")
    tp_triu.problems





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    INFO:root:Computing pca with `n_comps = {n_comps}` and `joint_space = {joint_space}`.
    INFO:root:Computing pca with `n_comps = {n_comps}` and `joint_space = {joint_space}`.
    INFO:root:Computing pca with `n_comps = {n_comps}` and `joint_space = {joint_space}`.
    INFO:root:Computing pca with `n_comps = {n_comps}` and `joint_space = {joint_space}`.
    INFO:root:Computing pca with `n_comps = {n_comps}` and `joint_space = {joint_space}`.
    INFO:root:Computing pca with `n_comps = {n_comps}` and `joint_space = {joint_space}`.

    {(10.0, 11.0): BirthDeathProblem[shape=(1024, 2048)], (11.0, 13.0): BirthDeathProblem[shape=(2048, 8192)], (12.0, 13.0): BirthDeathProblem[shape=(4096, 8192)], (10.0, 13.0): BirthDeathProblem[shape=(1024, 8192)], (11.0, 12.0): BirthDeathProblem[shape=(2048, 4096)], (10.0, 12.0): BirthDeathProblem[shape=(1024, 4096)]}



.. GENERATED FROM PYTHON SOURCE LINES 60-62

Explicit policy
~~~~~~~~~~~~~~~

.. GENERATED FROM PYTHON SOURCE LINES 62-67

.. code-block:: default


    tp_expl = TemporalProblem(adata)
    tp_expl = tp_expl.prepare(time_key="day", policy="explicit", subset=[(10,11), (12,13), (10,13)])
    tp_expl.problems





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    INFO:root:Computing pca with `n_comps = {n_comps}` and `joint_space = {joint_space}`.
    INFO:root:Computing pca with `n_comps = {n_comps}` and `joint_space = {joint_space}`.
    INFO:root:Computing pca with `n_comps = {n_comps}` and `joint_space = {joint_space}`.

    {(10, 11): BirthDeathProblem[shape=(1024, 2048)], (12, 13): BirthDeathProblem[shape=(4096, 8192)], (10, 13): BirthDeathProblem[shape=(1024, 8192)]}



.. GENERATED FROM PYTHON SOURCE LINES 68-70

Using the `filter` argument
***************************

.. GENERATED FROM PYTHON SOURCE LINES 72-73

If we want to use the sequential policy but restrict it to a certain subset of distributions we can use the `filter` argument.

.. GENERATED FROM PYTHON SOURCE LINES 73-78

.. code-block:: default


    tp_filtered = TemporalProblem(adata)
    tp_filtered = tp_filtered.prepare(time_key="day", policy="sequential", filter=[10, 12, 13])
    tp_filtered.problems





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    INFO:root:Computing pca with `n_comps = {n_comps}` and `joint_space = {joint_space}`.
    INFO:root:Computing pca with `n_comps = {n_comps}` and `joint_space = {joint_space}`.
    INFO:root:Computing pca with `n_comps = {n_comps}` and `joint_space = {joint_space}`.

    {(11.0, 12.0): BirthDeathProblem[shape=(2048, 4096)], (10.0, 11.0): BirthDeathProblem[shape=(1024, 2048)], (12.0, 13.0): BirthDeathProblem[shape=(4096, 8192)]}



.. GENERATED FROM PYTHON SOURCE LINES 79-80

Analogously, the `filter` argument can also be applied to other policies, e.g. the upper triangular policy.


.. rst-class:: sphx-glr-timing

   **Total running time of the script:** ( 0 minutes  2.583 seconds)


.. _sphx_glr_download_auto_examples_problems_ex_03_different_policies.py:

.. only:: html

  .. container:: sphx-glr-footer sphx-glr-footer-example


    .. container:: sphx-glr-download sphx-glr-download-python

      :download:`Download Python source code: ex_03_different_policies.py <ex_03_different_policies.py>`

    .. container:: sphx-glr-download sphx-glr-download-jupyter

      :download:`Download Jupyter notebook: ex_03_different_policies.ipynb <ex_03_different_policies.ipynb>`
