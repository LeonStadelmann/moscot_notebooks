
.. DO NOT EDIT.
.. THIS FILE WAS AUTOMATICALLY GENERATED BY SPHINX-GALLERY.
.. TO MAKE CHANGES, EDIT THE SOURCE PYTHON FILE:
.. "auto_examples/solvers/ex_linear_problems_basic.py"
.. LINE NUMBERS ARE GIVEN BELOW.

.. only:: html

    .. note::
        :class: sphx-glr-download-link-note

        Click :ref:`here <sphx_glr_download_auto_examples_solvers_ex_linear_problems_basic.py>`
        to download the full example code

.. rst-class:: sphx-glr-example-title

.. _sphx_glr_auto_examples_solvers_ex_linear_problems_basic.py:


Solving linear problems basic
-----------------------------
.. seealso::
    See :ref:`sphx_glr_auto_examples_solvers_ex_linear_problems_advanced.py` for an advanced
    example how to solve linear problems.
    See :ref:`sphx_glr_auto_examples_solvers_ex_quad_problems_basic.py` for an introduction
    to solving quadratic problems.
    See :ref:`sphx_glr_auto_examples_solvers_ex_quad_problems_advanced.py` for an advanced
    example how to solve quadratic problems.

.. GENERATED FROM PYTHON SOURCE LINES 15-18

This notebook elaborates on how to solve linear problems, e.g. the
:class:`moscot.problems.time.TemporalProblem` and the
:class:`moscot.problems.generic.SinkhornProblem`.

.. GENERATED FROM PYTHON SOURCE LINES 18-27

.. code-block:: default


    from moscot.datasets import simulate_data
    from moscot.problems.generic import SinkhornProblem

    import numpy as np

    adata = simulate_data(n_distributions=2, key="day")
    adata





.. rst-class:: sphx-glr-script-out

 Out:

 .. code-block:: none

    /home/runner/work/moscot_notebooks/moscot_notebooks/.tox/docs/lib/python3.9/site-packages/moscot/datasets/_datasets.py:251: FutureWarning: X.dtype being converted to np.float32 from float64. In the next version of anndata (0.9) conversion will not be automatic. Pass dtype explicitly to avoid this warning. Pass `AnnData(X, dtype=X.dtype, ...)` to get the future behavour.
      AnnData(
    /home/runner/work/moscot_notebooks/moscot_notebooks/.tox/docs/lib/python3.9/site-packages/anndata/_core/anndata.py:1785: FutureWarning: X.dtype being converted to np.float32 from float64. In the next version of anndata (0.9) conversion will not be automatic. Pass dtype explicitly to avoid this warning. Pass `AnnData(X, dtype=X.dtype, ...)` to get the future behavour.
      [AnnData(sparse.csr_matrix(a.shape), obs=a.obs) for a in all_adatas],

    AnnData object with n_obs × n_vars = 40 × 60
        obs: 'day', 'celltype'



.. GENERATED FROM PYTHON SOURCE LINES 28-39

Basic parameters
~~~~~~~~~~~~~~~~
`epsilon` is the regularization parameter. The lower `epsilon`, the sparser the
transport map. At the same time, the algorithm takes longer to converge. `tau_a`
and `tau_b` denote the unbalancedness parameters in the source and the target
distribution, respectively. `tau_a = 1` means the source marginals have to be fully
satisfied while `0 < tau_a < 1` relaxes this condition. Analogously, `tau_b` affects
the marginals of the target distribution. We demonstrate the effect of `tau_a` and `tau_b`
with the :class:`moscot.problems.generic.SinkhornProblem`.
Whenever the prior marginals `a` and `b` of the source and the target distribution,
respectively, are not passed (TODO link to marginals notebook), they are set to be uniform.

.. GENERATED FROM PYTHON SOURCE LINES 39-44

.. code-block:: default


    sp = SinkhornProblem(adata)
    sp = sp.prepare(key="day")
    print(sp[0, 1].a[:5], sp[0, 1].b[:5])





.. rst-class:: sphx-glr-script-out

 Out:

 .. code-block:: none

    INFO     Computing pca with `n_comps=30` using `adata.X`                        
    [0.05 0.05 0.05 0.05 0.05] [0.05 0.05 0.05 0.05 0.05]




.. GENERATED FROM PYTHON SOURCE LINES 45-49

First, we solve the problem in a balanced manner, such that the posterior marginals of the
solution (the sum over the rows and the columns for the source marginals and the
target marginals, respectively) are equal to the prior marginals up to small
errors (which define the convergence criterion in the balanced case).

.. GENERATED FROM PYTHON SOURCE LINES 49-53

.. code-block:: default

    sp = sp.solve(epsilon=1e-2, tau_a=1, tau_b=1)
    print(sp[0, 1].solution.a[:5], sp[0, 1].solution.b[:5])






.. rst-class:: sphx-glr-script-out

 Out:

 .. code-block:: none

    INFO     Solving problem OTProblem[stage='prepared', shape=(20, 20)].           
    [0.04999988 0.05000021 0.05000002 0.05000014 0.04999958] [0.04999239 0.04998733 0.04998971 0.04999597 0.0499909 ]




.. GENERATED FROM PYTHON SOURCE LINES 54-55

If we solve an unbalanced problem, the posterior marginals will be different.

.. GENERATED FROM PYTHON SOURCE LINES 55-58

.. code-block:: default

    sp = sp.solve(epsilon=1e-2, tau_a=0.9, tau_b=0.99)
    print(sp[0, 1].solution.a[:5], sp[0, 1].solution.b[:5])





.. rst-class:: sphx-glr-script-out

 Out:

 .. code-block:: none

    INFO     Solving problem OTProblem[stage='solved', shape=(20, 20)].             
    [0.03286438 0.02016632 0.02300303 0.01075798 0.01592067] [0.02210412 0.0259211  0.02502106 0.02436337 0.02419102]




.. GENERATED FROM PYTHON SOURCE LINES 59-66

Low-rank solutions
~~~~~~~~~~~~~~~~~~
Whenever the dataset is very large, the computational complexity can be
reduced by setting `rank` to a positive integer (:cite:`scetbon:21a`). In this
case, `epsilon` can also be set to 0, while only the balanced case
(`tau_a = tau_b = 1`) is supported. The `rank` should be significantly
smaller than the number of cells in both source and target distribution.

.. GENERATED FROM PYTHON SOURCE LINES 66-69

.. code-block:: default


    sp = sp.solve(epsilon=0, rank=3)





.. rst-class:: sphx-glr-script-out

 Out:

 .. code-block:: none

    INFO     Solving problem OTProblem[stage='solved', shape=(20, 20)].             




.. GENERATED FROM PYTHON SOURCE LINES 70-79

Scaling the cost
~~~~~~~~~~~~~~~~
`scale_cost` scales the cost matrix which often helps the algorithm to converge.
While any number can be passed, it is also possible to scale the cost matrix
by e.g. its mean, median, and maximum. We recommend using the `mean` as this
is possible without instantiating the cost matrix and hence reduces computational
complexity. Moreover, it is more stable w.r.t. outliers than for example scaling
by the maximum. Note that the solution of the Optimal Transport is not stable
across different scalings:

.. GENERATED FROM PYTHON SOURCE LINES 79-83

.. code-block:: default

    sp = sp.solve(epsilon=1e-2, scale_cost="mean")
    tm_mean = sp[0, 1].solution.transport_matrix
    print(tm_mean[:3, :3])





.. rst-class:: sphx-glr-script-out

 Out:

 .. code-block:: none

    INFO     Solving problem OTProblem[stage='solved', shape=(20, 20)].             
    [[7.7340994e-15 2.5644991e-07 5.3756791e-11]
     [3.7445882e-13 3.9273637e-06 8.2092007e-14]
     [4.3765991e-05 1.4413033e-10 5.2900635e-12]]




.. GENERATED FROM PYTHON SOURCE LINES 84-88

.. code-block:: default

    sp = sp.solve(epsilon=1e-2, scale_cost="max_cost")
    tm_max = sp[0, 1].solution.transport_matrix
    print(tm_max[:3, :3])





.. rst-class:: sphx-glr-script-out

 Out:

 .. code-block:: none

    INFO     Solving problem OTProblem[stage='solved', shape=(20, 20)].             
    [[7.8727094e-11 1.1196727e-05 4.5379775e-08]
     [8.0389750e-10 5.2311141e-05 4.0582340e-10]
     [5.9450121e-04 1.2423077e-07 1.6821049e-08]]




.. GENERATED FROM PYTHON SOURCE LINES 89-91

We can compute the correlation of the flattened transport matrix to get an
idea of the influence of different scalings.

.. GENERATED FROM PYTHON SOURCE LINES 91-93

.. code-block:: default

    correlation = np.corrcoef(tm_mean.flatten(), tm_max.flatten())[0, 1]
    print(f"{correlation:.4f}")




.. rst-class:: sphx-glr-script-out

 Out:

 .. code-block:: none

    0.9962





.. rst-class:: sphx-glr-timing

   **Total running time of the script:** ( 0 minutes  6.255 seconds)

**Estimated memory usage:**  24 MB


.. _sphx_glr_download_auto_examples_solvers_ex_linear_problems_basic.py:


.. only :: html

 .. container:: sphx-glr-footer
    :class: sphx-glr-footer-example



  .. container:: sphx-glr-download sphx-glr-download-python

     :download:`Download Python source code: ex_linear_problems_basic.py <ex_linear_problems_basic.py>`



  .. container:: sphx-glr-download sphx-glr-download-jupyter

     :download:`Download Jupyter notebook: ex_linear_problems_basic.ipynb <ex_linear_problems_basic.ipynb>`


.. only:: html

 .. rst-class:: sphx-glr-signature

    `Gallery generated by Sphinx-Gallery <https://sphinx-gallery.github.io>`_
